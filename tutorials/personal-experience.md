## Личный опыт использования

1. `Custom type` в `prismic/slicemachine` это страница или `layout`, для которых будем получать данные при помощи функций Next.js `getStaticProps()`, `getServerSideProps()`, `getInitialProps()`
2. Единственные данные, который добавила в `Custom type`, `uid` - уникальный идентификатор. В качестве `uid` удобно использовать название страницы. Все остальные данные хранятся в `Slice`, которые подключаются к `Custom type`
3. `Slice` хранят данные отдельных блоков страницы. Например, главная страница проекта https://prismic-sm-demo.netlify.app/ состоит из блоков
    ``` 
        - Header
        - Hero
        - Partners
        - Benefits
        - Stats
        - MobileApp
        - Testimonials
        - Conversion
        - Footer
    ```
4. Для каждого блока создаём отдельный `Slice`. Созданные `Slice` подключаем к `Custom type` `Home` и `Layout`
5. `Layout` для повторяющихся блоков обязателен, иначе данные в повторяющиеся блоки придётся загружать для каждой страницы отдельно: использование одного `Slice` в нескольких `Custom type` в  `prismic/slicemachine` допускается, но возможности копирования контента отдельного `Slice` нет
6. Из всех типов контента в абсолютном большинстве случаев использовала только два
    - `Key text` - простой неформатированный текст
    - `Image` - картинки
7. `Rich Text` не понравился тем, что его нельзя стилизовать указав `className`. Разработчики рекомендуют для каждого фрагмента текста с целью его форматирования добавлять блок-обёртку и уже ему указывать класс, что выглядит неоптимально с точки зрения вёрстки (лишние обёртки) и увеличения количества кода, который нужно написать и поддерживать (два элемента для каждого фрагмента текста вместо одного). Единственный момент, когда `Rich Text` действительно необходим, - добавление текста, состоящего из нескольких параграфов.
8. В каждом `Slice` есть две зоны `Non-Repeatable Zone` и `Repeatable Zone`. В первую добавляем элементы, которые в блоке присутствуют в единственном числе: заголовок, текст, кнопка, ссылка, картинка (если она одна). Во вторую любые повторяющиеся элементы, которые в коде хотим получить в виде массива: ссылки навигации, названия и логотипы компаний блока Partners, карточки блока Benefits, слайлы слайдера и т.д
9. Копирование фрагментов кода из `prismic/slicemachine` меня не устроило: по моему убеждению, CMS должна предоставлять данные, а код я напишу сама. Способ получения данных без разметки немного запутанный, по сравнению с официально рекомендуемым, но привыкнуть можно.  
Пример получения данных для главной страницы приложения:  
``` js
  import { createClient } from '../prismicio'

  export async function getStaticProps() {
    const client = createClient()
    const page = await client.getByUID('home', 'home')
    return {
      props: { page },
    }
  }

  function HomePage({ page }) {   
    return (
      <div>
        <Home page={page.data.slices} />
      </div>
    )
  }
```
10. В `Home` приходит массив данных, в котором каждому `Slice` соответвует отдельный элемент массива. Распределяем данные между компонентами:
```js
  const Home = ({ page }) => {
    return (
      <>
        <Hero data={page[0]} />
        <Partners data={page[1]} />
        <Benefits data={page[2]} />
        <Stats data={page[3]} />
        <MobileApp data={page[4]} />
        <Testimonials data={page[5]} />
      </>
    );
  };
```
11. Блоки получают данные в виде объектов с ключами `primary` и `items`. `Рrimary` - уникальные данные, присутствующие в единственном экземпляре, которые мы поместили в `Non-Repeatable Zone`, `items` - массив данных из `Repeatable Zone`.  
Названия элементов те, которые мы им дали, создавая эти элементы внутри `Slice`.
```js
const Stats = ({ data }) => {
  const { primary, items } = data;  
  const { statsTitle, statsSubTitle } = primary;
  const { statsNumber, statsNumberDescription } = items;
}
```
